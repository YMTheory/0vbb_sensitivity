#include "nEXOMbbVsMnuPlot.hh"

ClassImp(nEXOMbbVsMnuPlot);

nEXOMbbVsMnuPlot::nEXOMbbVsMnuPlot(const char* name, const char* title) : nEXOSensPlot(name,title)
{
}

nEXOMbbVsMnuPlot::~nEXOMbbVsMnuPlot() {}

TObject* nEXOMbbVsMnuPlot::GetPlot()
{
  // main function to return plot of half-life vs detector livetimembb vs nu mass (min, sum, etc)

  TCanvas* canvas = CreateEmptyCanvas();
  TLegend* leg = new TLegend(0.47, 0.13, 0.87, 0.28);
  
  //for(std::map<TString, TGraph>::iterator graph = fGraphs.begin(); graph != fGraphs.end(); graph++)
  //  PlotGraph(graph->second,*canvas,*leg);
  
  PlotEXO200(*canvas,*leg);

  canvas->cd();
  leg->Draw();
  canvas->Modified();
  canvas->Update();

  
  return canvas;  
}

TCanvas* nEXOMbbVsMnuPlot::CreateEmptyCanvas()
{
  Int_t nPoints = 1000;
  Int_t loRangeExp = 5;

  TH2D* h_axis = new TH2D(Form("h_axis_%s",GetName()), "", 1000, TMath::Power(10., -loRangeExp), 1., 1000, TMath::Power(10., -loRangeExp), 1.);
  h_axis->SetStats(false);
  h_axis->GetXaxis()->SetTitle("m_{min} (eV)");
  h_axis->GetYaxis()->SetTitle("m_{#beta#beta} (eV)");
  h_axis->GetXaxis()->CenterTitle();
  h_axis->GetXaxis()->SetTitleSize(0.04);	
  h_axis->GetYaxis()->CenterTitle();
  h_axis->GetYaxis()->SetTitleSize(0.04);
  h_axis->GetXaxis()->SetLabelSize(0.04);
  h_axis->GetYaxis()->SetLabelSize(0.04);
  
  TGraph* g_i_cv = new TGraph(nPoints*2);
  TGraph* g_n_cv = new TGraph(nPoints*2);
  TGraph* g_i_err = new TGraph(nPoints*2);
  TGraph* g_n_err = new TGraph(nPoints*2);

  g_i_cv->SetFillColor(kRed-9);
  g_n_cv->SetFillColor(kBlue-5);
  g_i_err->SetFillColor(0);
  g_n_err->SetFillColor(0);
  
  g_i_err->SetLineWidth(2);
  g_n_err->SetLineWidth(2);

  g_i_cv->SetFillStyle(1001);
  g_n_cv->SetFillStyle(1001);
  g_i_err->SetFillStyle(0);
  g_n_err->SetFillStyle(0);
  
  g_i_cv->SetLineColor(kRed);
  g_n_cv->SetLineColor(kBlue);
  g_i_err->SetLineColor(kRed);
  g_n_err->SetLineColor(kBlue);
  
  g_i_err->SetLineStyle(kDashed);
  g_n_err->SetLineStyle(kDashed);
  
  Int_t nLo = 0;//, nLo_68 = 0, nLo_90 = 0, nLo_95 = 0;
  Double_t mbb[4];
  Double_t mbb_lo[4];
  Double_t mbb_hi[4];
  for (Int_t i=0; i<nPoints; i++) {
    Double_t exponent = loRangeExp*(-1. + (Double_t)i/(nPoints-1));
    Double_t m_min = TMath::Power(10., exponent);
    
    //Make the graphs for the central values
    nEXONuOscPars::GetInstance()->EvalNormalMbbMmin(mbb, mbb_lo, mbb_hi, m_min, 2); // eval all possible mbbs from nu osc limits

    // find actual min and max mbb
    Int_t minBin = 0, maxBin = 0;
    Double_t min = 1.e6, min_lo=0.;
    Double_t max = -1.e6, max_hi=0.;
    for (int j=0; j<4; j++) {
      if (mbb[j] < min) {min = mbb[j]; minBin = j;}
      if (mbb[j] > max) {max = mbb[j]; maxBin = j;}
    }
    // switch with axis limit if outside of it
    if (min < TMath::Power(10., -loRangeExp) && nLo==0) nLo = 1;
    if (min > TMath::Power(10., -loRangeExp) && nLo==1) nLo = 2;
    if (min < TMath::Power(10., -loRangeExp) && nLo==2) nLo = 3;
    if (min > TMath::Power(10., -loRangeExp) && nLo==3) nLo = 4;		
    if (nLo==1 || nLo==2 || nLo==3) min = TMath::Power(10., -loRangeExp);
    min_lo = min-mbb_lo[minBin];
    max_hi = max+mbb_hi[maxBin];
    
    g_n_cv->SetPoint(i, m_min, max);
    g_n_cv->SetPoint(2*nPoints-i-1, m_min, min);	
    g_n_err->SetPoint(i, m_min, max_hi);
    g_n_err->SetPoint(2*nPoints-i-1, m_min, min_lo);	
    
    nEXONuOscPars::GetInstance()->EvalInvertedMbbMmin(mbb, mbb_lo, mbb_hi, m_min, 2);
    minBin = 0, maxBin = 0;
    min = 1.e6, min_lo=0.;
    max = -1.e6, max_hi=0.;
    for (int j=0; j<4; j++) {
      if (mbb[j] < min) {min = mbb[j]; minBin = j;}
      if (mbb[j] > max) {max = mbb[j]; maxBin = j;}
    }
    min_lo = min-mbb_lo[minBin];
    max_hi = max+mbb_hi[maxBin];
    
    g_i_cv->SetPoint(i, m_min, max);
    g_i_cv->SetPoint(2*nPoints-i-1, m_min, min);	
    g_i_err->SetPoint(i, m_min, max_hi);
    g_i_err->SetPoint(2*nPoints-i-1, m_min, min_lo);
  }
  
  
  TCanvas* cc = new TCanvas(GetName(),GetTitle());//"", 3000, 3000);
  cc->SetTickx();
  cc->SetTicky();
  cc->SetLogy();
  cc->SetLogx();
  h_axis->Draw();
  
  g_n_cv->Draw("same f");
  g_n_cv->Draw("same l");
  g_n_err->Draw("same f");
  g_n_err->Draw("same l");
  g_i_cv->Draw("same f");
  g_i_cv->Draw("same l");
  g_i_err->Draw("same f");
  g_i_err->Draw("same l");
  
  cc->RedrawAxis();
  return cc;
}

void 
