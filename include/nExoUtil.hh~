#ifndef NEXOUTIL
#define NEXOUTIL

#include <vector>

#include "TH2.h"
#include "TH1.h"
#include "TGraph.h"
#include "TCanvas.h"
#include "TString.h"

enum MATRIX_ELEMENT {GCM=0, QRPA2, RQRPA, NSM, IBM2};

class nExoUtil: public TObject {	
	public:
		//constructors
		nExoUtil();

 		//destructor
		virtual ~nExoUtil();

	private:
		Double_t 	fMatElem[5];
		TString		fMatElemName[5];
		TString		fMatElemTitle[5];
		TString		fMatElemAxisTitle[5];
		TString		fXaxisTitle;
		TString		fYaxisTitle;
		Double_t 	fDiscPlotRangeX[2];
		Double_t 	fDiscPlotRangeY[2];
		static const Int_t	fNBinsX = 2800;
		static const Int_t	fNBinsY = 650;
		Double_t		fFidVolXY;
		Double_t		fFidVolZZ;
		static const Double_t 	fXeMass = 4779.96;
		static const Double_t 	fEnrichment = 0.9;
		static const Double_t 	fXeMolarMass = 0.136;
		static const Double_t 	fAvogadrosNumber = 6.022e23;

		Double_t getMatElem(enum MATRIX_ELEMENT matElem) 			{return fMatElem[matElem];}
		TString getMatElemName(enum MATRIX_ELEMENT matElem) 		{return fMatElemName[matElem];}
		TString getMatElemTitle(enum MATRIX_ELEMENT matElem) 		{return fMatElemTitle[matElem];}
		TString getMatElemAxisTitle(enum MATRIX_ELEMENT matElem) {return fMatElemAxisTitle[matElem];}

	public:
		//histogram utility functions
		Double_t getFractional2DIntegral(TH2* h, Double_t xLo, Double_t xHi, Double_t yLo, Double_t yHi);
		TH2D* combineHistos(vector<TH2D*>* histos, vector<Double_t>* fracs, Double_t norm=1.);
		void rebin2DHistoFile(const char* inFileName, const char* outFileName, Int_t rebinX, Int_t rebinY);
		void normalizeHistoFile(const char* inFileName, const char* outFileName);
		void smoothHisto(TH2* histo, Bool_t isSS, Int_t startBin);
		void getSmoothArray(Double_t* smoothArray, TH2* histo, Bool_t isSS);
		Double_t getNumXeAtoms(Double_t xeMass) {return xeMass*fEnrichment*fAvogadrosNumber/fXeMolarMass;}

		//discovery potential calculating functions
		Double_t getLeastDetectableSignal(Double_t prob, Double_t nBkgd, Double_t nCrit);
		Double_t getCriticalCounts(Double_t alpha, Double_t nBkgd);
		Double_t getDiscoveryCounts(Double_t bkgCounts, Double_t gausSignif, Double_t prob, Double_t eff=1.);
		vector<Double_t> getListOfDiscoveryCounts(vector<Double_t> bkgCounts, Double_t gausSignif, Double_t prob, Double_t eff);
		Double_t getBkgdCountsInRange(const char* histFile, Double_t yrsExp, Int_t nPdfs, Double_t meanPerYear[], TString pdfNames[], Double_t* xRange, Double_t* yRange, Bool_t isBaTag=false);
		Double_t getHalfLifeForCounts(Double_t nYrs, Double_t counts, Double_t xeMass);
		Double_t getCutValue(TH1D* histo, Double_t gausSignif);

		//drawing functions
		TGraph* getInvertedGraph		(enum MATRIX_ELEMENT matElem);
		TGraph* getNormalGraph			(enum MATRIX_ELEMENT matElem);
		TCanvas* getEmptyDiscoveryPlot(enum MATRIX_ELEMENT matElem, Double_t xMin=0., Double_t xMax=10., Double_t yMin=1.e25, Double_t yMax=2.e29);

		//other functions
		Double_t getCo60CountsAfterYears(Double_t meanPerYear, Double_t yrs); 

  		ClassDef(nExoUtil,1)	//Class to look after the fit setup for nEXO. 
};

#endif
